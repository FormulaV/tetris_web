<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris — Multiplayer (PeerJS only)</title>

<!-- PeerJS -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<style>
:root{
    --bg-color:#32534f; --panel-bg:#0a1a1f; --accent:#c0f0f0; --muted:#a0d0d0;
    --grid-line: rgba(255,255,255,0.08); --outer-border: #4499b2;
}
*{box-sizing:border-box}
body{
    margin:0;
    background:linear-gradient(180deg, #3f7069 0%, #32534f 100%);
    color:#e6f0f0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex; justify-content: center; align-items: center;
    min-height: 100vh; overflow: hidden;
}
.wrap{ display:flex; gap:25px; align-items:flex-start; justify-content:center; padding:28px; max-width:100%;}
.game{ background:var(--panel-bg); padding:10px; border-radius:2px; box-shadow:0 0 15px rgba(0,0,0,0.8); border: 2px solid var(--outer-border); }
canvas#board{ background:#02040a; display:block; border-radius:0; }
.info-wrap{ display: flex; flex-direction: column; gap: 8px; width: 140px; }
.info{ width:100%; padding:8px 12px; background:var(--panel-bg); border-radius:2px; border: 2px solid var(--outer-border); box-shadow:0 0 10px rgba(0,0,0,0.5); }
h1{display:none}
.next-panel, .hold-panel { width: 100%; padding: 8px; background: var(--panel-bg); border: 2px solid var(--outer-border); box-shadow: 0 0 10px rgba(0,0,0,0.5); border-radius: 2px; text-align: center; }
.next-panel h3, .hold-panel h3 { color: var(--accent); font-size: 14px; margin: 0 0 5px 0; font-weight: 400; letter-spacing: 1px; }
.nextCanvas, .holdCanvas{ background:#041226; border-radius:2px; padding:4px; margin: 0 auto; display: block; }
.stat-box{ color: var(--accent); text-align: right; font-size: 16px; font-weight: 700; margin-top: 2px; padding-right: 5px; }
.stat-label{ color: var(--muted); font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin-top: 5px; }
.stat-group{ margin-bottom: 5px; padding-left: 5px; }
#time-box { margin-top: 8px; padding: 8px 12px; text-align: center; }
#time-label { font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 1px; }
#time-value { font-size: 24px; color: var(--accent); font-weight: 700; margin-top: 2px; }
.controls, .small, footer { display: none; } 
.btn{ background: #0b1b2a; color: var(--accent); border: 1px solid var(--accent); padding: 6px 10px; border-radius: 6px; cursor: pointer; transition: background 0.2s; }
.btn:hover{ background: #1a2c38; }
.overlay{position:fixed;inset:0;background:rgba(2,6,23,0.92);display:flex;align-items:center;justify-content:center;z-index:10000}
.panel{ background:var(--panel-bg); padding:20px; border-radius:12px; min-width:280px; max-width: 90vw; max-height: 90vh; overflow-y: auto; border: 2px solid var(--outer-border); text-align: center; }
#gameOverMenu h2 { color: #f00; margin-top: 0; font-size: 28px; text-shadow: 0 0 10px #f00; }
#multiplayerStatus { color: #ffcc00; font-size: 12px; margin-top: 10px; text-align: center; }
.rival-score { color: #ff99ff; }
.status-msg { font-size: 12px; margin-top: 10px; color: #ffff00; min-height: 1.2em; display: none; }
@media(max-width:720px){ .wrap{ flex-direction:column; align-items:center; padding: 10px; } .info-wrap{width:95%} }
</style>
</head>
<body>
<!-- MAIN MENUS -->
<div id="mainMenu" class="overlay">
  <div class="panel">
    <h1 style="color:var(--accent);margin:4px 0 12px 0; display: block;">TETRIS ONLINE</h1>
    <div style="display:flex;flex-direction:column;gap:10px;align-items:center">
      <button id="singleplayerBtn" class="btn">Singleplayer</button>
      <button id="multiplayerBtn" class="btn">Multiplayer (Online)</button>
      <button id="openSettingsBtn" class="btn">Settings</button>
    </div>
    <div style="margin-top:15px; font-size:11px; color:#888;">PeerJS Enabled</div>
  </div>
</div>

<div id="singleplayerMenu" class="overlay" style="display:none;">
    <div class="panel">
        <h2 style="color:var(--accent);margin:4px 0 12px 0;">SINGLEPLAYER</h2>
        <div style="display:flex;flex-direction:column;gap:10px;align-items:center">
            <button id="startBtn" class="btn">Start Game</button>
            <button id="backFromSPBtn" class="btn">Back</button>
        </div>
    </div>
</div>

<div id="multiplayerMenu" class="overlay" style="display:none;">
    <div class="panel">
        <h2 style="color:#f0f000;margin:4px 0 12px 0;">MULTIPLAYER</h2>
        <p style="font-size:12px; color:#ccc; margin-bottom:15px;">Main dengan teman di device berbeda!</p>
        <div style="display:flex;flex-direction:column;gap:10px;align-items:center">
            <button id="openHostMenuBtn" class="btn">Host Game (Buat Room)</button>
            <button id="openJoinMenuBtn" class="btn">Join Game (Masukkan Room ID)</button>
            <button id="backFromMPBtn" class="btn">Back</button>
        </div>
    </div>
</div>

<div id="myGameOverOverlay" class="overlay" style="display:none;">
    <div class="panel">
        <h2 style="color:#ffcc00;margin-top:0">Game Over</h2>
        <p>Anda telah selesai bermain.</p>
        <button id="btnCheckResult" class="btn">Lihat Hasil</button>
    </div>
</div>


<div id="hostGameMenu" class="overlay" style="display:none;">
    <div class="panel">
        <h2 style="color:#00f0f0;margin:4px 0 12px 0;">HOST GAME</h2>
        <p style="color:var(--muted); font-size: 14px;">Buat nama room unik (tanpa spasi).</p>
        <div style="display:flex;flex-direction:column;gap:10px;align-items:center; margin-top: 15px;">
            <input type="text" id="hostRoomNameInput" placeholder="Contoh: mabar123" style="padding:8px; border-radius:6px; border:1px solid var(--accent); background:#061226; color:var(--accent); width: 100%;">
            <button id="createRoomBtn" class="btn">Buat & Tunggu</button>
            <button id="backFromHostBtn" class="btn">Kembali</button>
            <div id="hostStatus" class="status-msg"></div>
        </div>
    </div>
</div>

<div id="joinGameList" class="overlay" style="display:none;">
    <div class="panel">
        <h2 style="color:#f0f000;margin:4px 0 12px 0;">JOIN GAME</h2>
        <p style="color:var(--muted); font-size: 14px;">Masukkan nama room host.</p>
        <div style="display:flex;flex-direction:column;gap:10px;align-items:center; margin-top: 15px;">
             <input type="text" id="joinRoomNameInput" placeholder="Masukkan Nama Room Host" style="padding:8px; border-radius:6px; border:1px solid var(--accent); background:#061226; color:var(--accent); width: 100%;">
            <button id="connectBtn" class="btn">Connect ke Room</button>
            <button id="backFromJoinBtn" class="btn">Kembali</button>
            <div id="joinStatus" class="status-msg"></div>
        </div>
    </div>
</div>

<div id="hostWaitingRoom" class="overlay" style="display:none;">
    <div class="panel">
        <h2 style="color:#00f0f0;margin:4px 0 12px 0;">LOBBY: <span id="lobbyRoomName">...</span></h2>
        <p style="color:var(--muted);">Status Koneksi: <span id="connectionStatus" style="color:#fff">Menunggu...</span></p>

        <div style="display:flex; justify-content:center; gap: 40px; margin: 20px 0;">
            <div style="padding: 10px; border: 1px solid var(--accent); border-radius: 6px; background: #1a2c38;">
                <h3 style="margin: 0; color: var(--accent);">PLAYER 1 (HOST)</h3>
                <p style="margin: 5px 0 0 0; color: #fff;">Ready</p>
            </div>

            <div id="player2Box" style="padding: 10px; border: 1px dashed var(--muted); border-radius: 6px; background: #1a2c38;">
                <h3 style="margin: 0; color: var(--muted);">PLAYER 2</h3>
                <p id="player2Name" style="margin: 5px 0 0 0; color: #fff;">*Menunggu...*</p>
            </div>
        </div>

        <div style="display:flex;flex-direction:column;gap:10px;align-items:center; margin-top: 15px;">
            <button id="startGameMultiplayerBtn" class="btn" disabled style="background:#444;">Start Game</button>
            <button id="closeRoomBtn" class="btn">Disconnect & Keluar</button>
        </div>
    </div>
</div>

<div id="waitingOpponentOverlay" class="overlay" style="display:none;">
    <div class="panel">
        <h2 style="color:#ffcc00; margin-top:0">ANDA GAME OVER</h2>
        <p>Score Anda: <span id="waitingMyScore" style="font-weight:bold; color:var(--accent);">0</span></p>
        <p style="color:var(--muted);">Menunggu lawan menyelesaikan permainan...</p>
        <button id="btnCheckResult" class="btn" style="margin-top:15px; display:none;">
            Cek Hasil
        </button>
    </div>
</div>


<div id="multiplayerResultsMenu" class="overlay" style="display:none;">
    <div class="panel">
        <h2 style="color:var(--accent); margin-top:0">HASIL PERTANDINGAN</h2>
        <h3 id="winnerMessage" style="color:#00ff00; margin: 15px 0;">Pemenang: ...</h3>
        <table style="width: 100%; max-width: 320px; margin: 20px auto; border-collapse: collapse;">
            <thead><tr style="border-bottom: 1px solid var(--muted);"><th style="padding: 8px; color: var(--muted);">PLAYER</th><th style="padding: 8px; color: var(--muted);">SKOR AKHIR</th></tr></thead>
            <tbody>
                <tr id="player1Result"><td style="padding: 8px; color: var(--accent); font-weight: bold;">PLAYER 1 (HOST)</td><td id="p1FinalScore" style="padding: 8px; color: var(--accent); font-weight: bold;">0</td></tr>
                <tr id="player2Result"><td style="padding: 8px; color: #ff99ff; font-weight: bold;">PLAYER 2</td><td id="p2FinalScore" style="padding: 8px; color: #ff99ff; font-weight: bold;">0</td></tr>
            </tbody>
        </table>
        <button id="exitFromResultsBtn" class="btn">Kembali ke Menu Utama</button>
    </div>
</div>

<div id="settingsMenu" class="overlay" style="display:none;">
  <div class="panel">
    <h2 style="color:var(--accent);margin-top:0">Settings</h2>
    <label class="small">Music Volume</label><br><input id="musicVolume" type="range" min="0" max="1" step="0.01" value="0.20" style="width:100%"><br><br>
    <label class="small">SFX Volume</label><br><input id="sfxVolume" type="range" min="0" max="1" step="0.01" value="0.18" style="width:100%"><br><br>
    <label class="small">Theme</label><br><select id="themeSelect" style="width:100%;padding:8px;margin-top:6px;border-radius:8px;background:#061226;color:var(--accent);border:0"><option value="default">Default</option><option value="neon">Neon</option><option value="pastel">Pastel</option></select>
    <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end"><button id="closeSettingsBtn" class="btn">Back</button></div>
  </div>
</div>

<div id="pauseMenu" class="overlay" style="display:none;">
  <div class="panel"><h2 style="color:var(--accent);margin-top:0">Paused</h2><div style="display:flex;flex-direction:column;gap:8px"><button id="resumeBtn" class="btn">Resume</button><button id="restartBtn" class="btn">Restart</button><button id="settingsFromPauseBtn" class="btn">Settings</button><button id="exitToMenuBtn" class="btn">Exit to Main Menu</button></div></div>
</div>

<div id="gameOverMenu" class="overlay" style="display:none;">
  <div class="panel"><h2>GAME OVER!</h2><p>Score Akhir: <span id="finalScore" style="font-size: 24px; font-weight: 700; color: var(--accent);">0</span></p><p>High Score: <span id="finalHighScore" style="font-size: 16px; color: var(--muted);">0</span></p><div style="display:flex;flex-direction:column;gap:8px; margin-top: 15px;"><button id="restartFromGameOverBtn" class="btn">Restart</button><button id="exitFromGameOverBtn" class="btn">Kembali ke Menu Utama</button></div></div>
</div>
<div class="wrap">
    <div class="info-wrap">
        <div class="hold-panel"><h3>Ⓗ HOLD</h3><canvas id="hold" class="holdCanvas" width="120" height="80"></canvas></div>
        <div class="info">
            <div class="stat-group"><div class="stat-label">LINES</div><div id="lines" class="stat-box">0</div></div>
            <div class="stat-group"><div class="stat-label">LEVEL</div><div id="level" class="stat-box">1</div></div>
            <div class="stat-group"><div class="stat-label">SCORE</div><div id="score" class="stat-box">0</div></div>
            <div class="stat-group"><div class="stat-label">HIGH SCORE</div><div id="highscore" class="stat-box">0</div></div>
            <div id="multiplayerStatus" style="font-size:11px; margin-top:10px; text-align:center;">Mode: Singleplayer</div>
            <div id="rivalScoreContainer" class="stat-group" style="display:none; margin-top: 10px;">
                <div class="stat-label rival-score">RIVAL SCORE</div>
                <div id="rivalScore" class="stat-box rival-score">0</div>
            </div>
            <div style="margin-top:10px; display: none;"><button id="btnRestart2" class="btn">Restart</button><button id="btnToggleSound2" class="btn">Toggle Sound</button><button id="btnOpenPause" class="btn">Menu</button></div>
        </div>
    </div>
    <div class="game"><canvas id="board" width="300" height="600"></canvas></div>
    <div class="info-wrap">
        <div class="next-panel"><h3>NEXT</h3><canvas id="next" class="nextCanvas" width="120" height="180"></canvas></div>
        <div class="info" id="time-box"><div id="time-label">TIME</div><div id="time-value">00:00:00</div></div>
    </div>
</div>

<footer>Multiplayer powered by PeerJS</footer>
<script>
/* CORE GAME + PEERJS (PeerJS-only multiplayer) */
/* Based on your uploaded files. Sources: dari-gemini-peerjs.html + tetri-multi.html. :contentReference[oaicite:2]{index=2} :contentReference[oaicite:3]{index=3} */

// DOM
const boardCanvas = document.getElementById('board');
const ctx = boardCanvas.getContext('2d');
const nextCanvasCtx = document.getElementById('next').getContext('2d');
const holdCanvasCtx = document.getElementById('hold').getContext('2d');

const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');
const linesEl = document.getElementById('lines');
const timeEl = document.getElementById('time-value');
const finalScoreEl = document.getElementById('finalScore');
const finalHighScoreEl = document.getElementById('finalHighScore');
const multiplayerStatusEl = document.getElementById('multiplayerStatus');
const rivalScoreEl = document.getElementById('rivalScore');
const rivalScoreContainer = document.getElementById('rivalScoreContainer');

// Multiplayer UI refs
const hostRoomNameInput = document.getElementById('hostRoomNameInput');
const joinRoomNameInput = document.getElementById('joinRoomNameInput');
const hostStatusText = document.getElementById('hostStatus');
const joinStatusText = document.getElementById('joinStatus');
const lobbyRoomName = document.getElementById('lobbyRoomName');
const player2Name = document.getElementById('player2Name');
const player2Box = document.getElementById('player2Box');
const connectionStatus = document.getElementById('connectionStatus');
const winnerMessage = document.getElementById('winnerMessage');
const p1FinalScore = document.getElementById('p1FinalScore');
const p2FinalScore = document.getElementById('p2FinalScore');
const waitingMyScore = document.getElementById('waitingMyScore');

// Gameplay constants & state
const COLS = 10, ROWS = 20, BLOCK = 30;
let board = [];
let score = 0, highScore = parseInt(localStorage.getItem('tetris_highscore') || '0', 10) || 0;
let level = 1, totalLines = 0;
let dropCounter = 0, dropInterval = 1000, lastTime = 0;
let current = null, nextPiece = null, holdPiece = null;
let isPaused = true, isRunning = false;
let gameStartTime = 0;
let isViewingResults = false;


const SHAPES = { I:[[1,1,1,1]], O:[[1,1],[1,1]], T:[[0,1,0],[1,1,1]], J:[[1,0,0],[1,1,1]], L:[[0,0,1],[1,1,1]], S:[[0,1,1],[1,1,0]], Z:[[1,1,0],[0,1,1]] };
const COLORS = { I:'rgb(0,240,240)', O:'rgb(240,240,0)', T:'rgb(160,0,240)', J:'rgb(0,0,240)', L:'rgb(240,140,0)', S:'rgb(0,240,0)', Z:'rgb(240,0,0)' };
const BAG = ['I','O','T','J','L','S','Z'];
let bag = [];

// Audio
let audioCtx = null, musicGain = null, sfxGain = null, soundOn = true, bgmTimer = null;
function ensureAudio(){
    if(!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        musicGain = audioCtx.createGain();
        sfxGain = audioCtx.createGain();
        musicGain.gain.value = 0.2;
        sfxGain.gain.value = 0.18;
        musicGain.connect(audioCtx.destination);
        sfxGain.connect(audioCtx.destination);
    }
    if(soundOn) startBGM();
}
function playSimple(type){
    if(!soundOn || !audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    if(type === 'click'){ o.type='sine'; o.frequency.setValueAtTime(600,audioCtx.currentTime); g.gain.setValueAtTime(0.12,audioCtx.currentTime); }
    if(type === 'clear'){ o.type='sawtooth'; o.frequency.setValueAtTime(250,audioCtx.currentTime); g.gain.setValueAtTime(0.18,audioCtx.currentTime); }
    if(type === 'drop'){ o.type='triangle'; o.frequency.setValueAtTime(120,audioCtx.currentTime); g.gain.setValueAtTime(0.08,audioCtx.currentTime); }
    o.connect(g); g.connect(sfxGain); o.start(); o.stop(audioCtx.currentTime + 0.15);
}
let bgmTimerRef = null;
function startBGM(){
    if(!audioCtx || !soundOn) return;
    stopBGM();
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const notes = [220,330,440,330];
    const t0 = audioCtx.currentTime;
    notes.forEach((n,i)=>{ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.setValueAtTime(n,t0 + i*0.15); g.gain.setValueAtTime(0.03,t0 + i*0.15); o.connect(g); g.connect(musicGain); o.start(t0 + i*0.15); o.stop(t0 + i*0.15 + 0.4); });
    bgmTimerRef = setTimeout(()=>{ if(soundOn) startBGM(); }, 600);
}
function stopBGM(){ if(bgmTimerRef){ clearTimeout(bgmTimerRef); bgmTimerRef = null; } }

// Utils & bag
function randBag(){ const b = BAG.slice(); for(let i=b.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [b[i],b[j]]=[b[j],b[i]]; } return b; }
function nextFromBag(){ if(bag.length===0) bag = randBag(); return bag.pop(); }
function createPiece(key){ return { key, shape: SHAPES[key].map(r=>r.slice()), x: Math.floor(COLS/2 - Math.ceil(SHAPES[key][0].length/2)), y: 0, color: COLORS[key] }; }
function rotateShape(shape){ const H=shape.length,W=shape[0].length; const out=Array.from({length:W},()=>Array(H).fill(0)); for(let r=0;r<H;r++) for(let c=0;c<W;c++) out[c][H-1-r]=shape[r][c]; return out; }
function collide(board, shape, x, y){ for(let r=0;r<shape.length;r++) for(let c=0;c<shape[r].length;c++) if(shape[r][c]){ const bx=x+c, by=y+r; if(bx<0||bx>=COLS||by>=ROWS) return true; if(by>=0 && board[by][bx]) return true; } return false; }

// Event bindings & helpers
function bind(id, fn){ const el=document.getElementById(id); if(el) el.onclick=fn; else console.warn('Missing:', id); }
window.onload = function(){
    boardCanvas.width = COLS*BLOCK; boardCanvas.height = ROWS*BLOCK;
    bind('singleplayerBtn', ()=>showMenu('singleplayerMenu'));
    bind('multiplayerBtn', ()=>showMenu('multiplayerMenu'));
    bind('openSettingsBtn', ()=>showMenu('settingsMenu'));
    bind('startBtn', startSingleplayer);
    bind('backFromSPBtn', showMainMenu);
    bind('backFromMPBtn', showMainMenu);
    bind('openHostMenuBtn', ()=>showMenu('hostGameMenu'));
    bind('openJoinMenuBtn', ()=>showMenu('joinGameList'));
    bind('backFromHostBtn', ()=>showMenu('multiplayerMenu'));
    bind('backFromJoinBtn', ()=>showMenu('multiplayerMenu'));
    bind('createRoomBtn', hostGame);
    bind('connectBtn', joinGame);
    bind('startGameMultiplayerBtn', requestStartGame);
    bind('closeRoomBtn', disconnectMultiplayer);
    bind('restartFromGameOverBtn', ()=>startSingleplayer());
    bind('exitFromGameOverBtn', showMainMenu);
    bind('exitFromResultsBtn', disconnectMultiplayer);
    bind('closeSettingsBtn', ()=>{ document.getElementById('settingsMenu').style.display='none'; if(isRunning && isPaused) document.getElementById('pauseMenu').style.display='flex'; else if(!isRunning) document.getElementById('mainMenu').style.display='flex'; });
    document.getElementById('musicVolume').oninput = (e)=>{ if(musicGain) musicGain.gain.value = e.target.value; };
    document.getElementById('sfxVolume').oninput = (e)=>{ if(sfxGain) sfxGain.gain.value = e.target.value; };
    bind('resumeBtn', resumeGame);
    bind('restartBtn', ()=>startSingleplayer());
    bind('exitToMenuBtn', disconnectMultiplayer);
    window.addEventListener('keydown', handleInput);
    document.body.addEventListener('click', function(){ if(!audioCtx && soundOn) ensureAudio(); }, {once:true});
    showMainMenu();

    const btnCheckResult = document.getElementById('btnCheckResult');
    if(btnCheckResult){
        btnCheckResult.onclick = () => {
            isViewingResults = true;
            // Pastikan UI Game Over hilang dan tampilkan hasil sementara
            hideAllMenus();
            document.getElementById('multiplayerResultsMenu').style.display = 'flex';

            // Kita minta lawan untuk kirim final score (jika lawan sudah game over, dia akan reply FINAL_SCORE).
            if(conn && conn.open){
                sendData({ type: 'REQUEST_RESULT' });
            }

            // Pastikan UI hasil ter-update dengan skor yang kita punya saat ini
            updateMultiplayerResultUI();
        };
    }



    document.getElementById('btnCheckResult').onclick = () => {
    sendData({ type: 'REQUEST_RESULT' });
    showMultiplayerResults();

    document.getElementById('btnCheckResult').onclick = () => {
    hideAllMenus();
    document.getElementById('multiplayerResultsMenu').style.display = 'flex';

    // Kirim request result ke lawan (biar sama-sama buka hasil)
    sendData({ type: 'REQUEST_RESULT' });

    checkIfFinalResult();
};

};

};
function showMenu(id){ hideAllMenus(); const el=document.getElementById(id); if(el) el.style.display='flex'; }
function hideAllMenus(){ const els=document.querySelectorAll('.overlay'); els.forEach(e=>e.style.display='none'); }
function showMainMenu(){ hideAllMenus(); document.getElementById('mainMenu').style.display='flex'; isRunning=false; isPaused=true; isMultiplayer=false; multiplayerStatusEl.innerText='Mode: Singleplayer'; rivalScoreContainer.style.display='none'; stopBGM(); }
// Input handlers
function handleInput(e){ if(e.repeat || isPaused || !isRunning) return; const k=e.key.toLowerCase(); if(k==='arrowleft'||k==='a') move(-1); else if(k==='arrowright'||k==='d') move(1); else if(k==='arrowup'||k==='w') rotateCurrent(); else if(k==='arrowdown'||k==='s') softDrop(); else if(e.code==='Space') hardDrop(); else if(k==='c') swapHold(); else if(k==='p') { if(isPaused) resumeGame(); else { isPaused=true; showMenu('pauseMenu'); } } }
/* -------------------
   PEERJS NETWORKING
   -------------------
   Pure PeerJS flow: host uses deterministic ID "tetris-p2p-<roomName>",
   joiner creates random peer and connects to that ID.
*/

let peer = null;
let conn = null;
let isMultiplayer = false;
let isHost = false;
let myPeerID = null;
let opponentScore = 0;
let opponentGameOver = false;
const APP_PREFIX = "tetris-p2p-final-"; // unique prefix

// HOST: create Peer with deterministic ID and accept incoming connection
function hostGame(){
    const name = hostRoomNameInput.value.trim();
    if(!name) return alert("Masukkan nama room!");
    if(!/^[a-zA-Z0-9]+$/.test(name)) return alert("Nama room hanya boleh huruf dan angka!");
    if(hostStatusText){ hostStatusText.style.display='block'; hostStatusText.innerText='Membuat Room ID...'; }

    const id = APP_PREFIX + name;
    peer = new Peer(id);

    peer.on('open', id=>{
        if(hostStatusText) hostStatusText.style.display='none';
        isHost = true; isMultiplayer = true; myPeerID = id;
        enterLobby(name);
    });

    peer.on('connection', (connection)=>{
        if(conn){ connection.close(); return; } // already have opponent
        conn = connection;
        setupConnection();
        // send initial connected payload after a small delay
        setTimeout(()=>{ sendData({ type:'CONNECTED', roomName:name }); updateLobbyUI(true); }, 400);
    });

    peer.on('error', err=>{
        console.error(err);
        if(err && err.type === 'unavailable-id') alert("Nama Room sudah dipakai! Coba nama lain.");
        else alert("PeerJS error: " + (err && err.type ? err.type : String(err)));
        if(hostStatusText) hostStatusText.style.display='none';
    });
}

// JOIN: create Peer (auto id) and connect to host id
function joinGame(){
    const name = joinRoomNameInput.value.trim();
    if(!name) return alert("Masukkan nama room host!");
    if(joinStatusText){ joinStatusText.style.display='block'; joinStatusText.innerText='Menghubungkan ke Host...'; }

    peer = new Peer();
    peer.on('open', ()=>{
        const targetId = APP_PREFIX + name;
        conn = peer.connect(targetId);

        conn.on('open', ()=>{
            setupConnection();
            if(joinStatusText) joinStatusText.style.display='none';
            isHost = false; isMultiplayer = true;
            enterLobby(name);
        });

        conn.on('error', err=>{
            console.warn('conn error', err);
            if(joinStatusText){ joinStatusText.style.display='block'; joinStatusText.innerText='Gagal connect ke host.'; }
        });

        setTimeout(()=>{
            if(!conn || !conn.open){
                if(joinStatusText) joinStatusText.innerText = "Gagal menghubungkan (Host offline / Room tidak ada).";
            }
        }, 5000);
    });

    peer.on('error', err=>{
        alert("PeerJS error: " + (err && err.type ? err.type : String(err)));
        if(joinStatusText) joinStatusText.style.display='none';
    });
}

function setupConnection(){
    if(!conn) return;
    conn.on('data', (data)=>{ handleNetworkData(data); });
    conn.on('close', ()=>{ alert("Koneksi terputus!"); disconnectMultiplayer(); });
    conn.on('error', (e)=>{ console.warn('conn err', e); });
}

// Handle incoming messages from opponent
function handleNetworkData(data){
    if(!data || !data.type) return;
    switch(data.type){
        case 'CONNECTED':
            updateLobbyUI(true);
            break;

        case 'START_GAME':
            startGameMultiplayer();
            break;

        case 'UPDATE_SCORE':
            if (isViewingResults) updateMultiplayerResultUI();
            // realtime update skor lawan saat bermain
            if(typeof data.score !== 'undefined') {
                opponentScore = Number(data.score) || 0;
                if(rivalScoreEl) rivalScoreEl.innerText = opponentScore.toLocaleString();
            }
            break;

        case 'ATTACK':
            addGarbageLines(data.count || 0);
            break;

        case 'GAME_OVER':
            // opponent finished; record final score (from peer)
            opponentGameOver = true;
            opponentScore = Number(data.score) || 0;
            // Update rival UI if visible
            if(rivalScoreEl) rivalScoreEl.innerText = opponentScore.toLocaleString();

            // If I already finished too, show results now (both sides have reported)
            if(!isRunning){
                // I already gameover -> I and opponent both done, ensure both final scores visible
                // If I haven't sent my final score to opponent yet (safety), send it now
                if(conn && conn.open) sendData({ type:'FINAL_SCORE', score: score });
                showMultiplayerResults();
            } else {
                // I'm still playing; opponent finished first.
                // Do NOT auto show final results. The opponent who is already game over will see his overlay
                // If the opponent pressed "Cek Hasil" they'll request final; but we still update UI so host/other can see opponent score.
                // No extra action needed here besides updating UI.
                if(document.getElementById('multiplayerResultsMenu') && 
                   document.getElementById('multiplayerResultsMenu').style.display === 'flex'){
                    // If other side already viewing results, refresh UI to show opponent score
                    updateMultiplayerResultUI();
                }
            }
            break;

        case 'REQUEST_RESULT':
            // Lawan meminta data final
            if(conn && conn.open){
                sendData({ type:'FINAL_SCORE', score });
            }

            // ❌ Jangan buka UI hasil di sini
            // Pemain ini hanya update data saja
            updateMultiplayerResultUI();
            break;

        case 'FINAL_SCORE':
            if (isViewingResults) updateMultiplayerResultUI();
            // Received opponent's final score as reply to REQUEST_RESULT or direct send
            opponentGameOver = true;
            opponentScore = Number(data.score) || 0;
            if(rivalScoreEl) rivalScoreEl.innerText = opponentScore.toLocaleString();
            // If I'm already done (not running), show final results. Otherwise update result UI if open.
            if(!isRunning || document.getElementById('multiplayerResultsMenu').style.display === 'flex'){
                updateMultiplayerResultUI();
                // If both finished, ensure both see result
                if(!isRunning && opponentGameOver){
                    showMultiplayerResults();
                }
            }
            break;

        case 'DISCONNECT_FORCE':
            // host/peer forced disconnect — clean up
            forceReturnToMainMenu();
            break;

        default:
            console.warn('Unknown network data type:', data.type);
            break;
    }
}


function sendData(data){
    try {
        if(conn && conn.open){
            conn.send(data);
        } else {
            console.warn('Tried to send but no open connection', data);
        }
    } catch(e){
        console.warn('sendData error', e);
    }
}


// Lobby UI helpers
function enterLobby(roomName){
    hideAllMenus();
    document.getElementById('hostWaitingRoom').style.display='flex';
    lobbyRoomName.innerText = roomName;
    player2Name.innerText = "*Menunggu...*";
    player2Name.style.color = "#fff";
    player2Box.style.border = "1px dashed #94a3b8";
    connectionStatus.innerText = isHost ? "Menunggu Joiner..." : "Terhubung ke Host";

    const startBtn = document.getElementById('startGameMultiplayerBtn');
    if(!isHost){
        startBtn.style.display='none';
        player2Name.innerText = "Anda (Joiner)";
        player2Name.style.color = "#00ff00";
        player2Box.style.border = "1px solid #00ff00";
    } else {
        startBtn.style.display='block';
        startBtn.disabled = true; startBtn.style.background='#444';
    }
}

function updateLobbyUI(connected){
    if(connected){
        connectionStatus.innerText = "Pemain Siap!";
        if(isHost){
            player2Name.innerText = "Player 2 (Ready)";
            player2Name.style.color = "#00ff00";
            player2Box.style.border = "1px solid #00ff00";
            const startBtn = document.getElementById('startGameMultiplayerBtn');
            startBtn.disabled = false; startBtn.style.background='var(--accent)';
        }
    }
}

function requestStartGame(){
    if(!isHost || !conn || !conn.open) return alert("Tidak bisa memulai — pemain belum terhubung.");
    // Host instructs joiner to start as well
    sendData({ type: 'START_GAME' });
    // Host also starts locally
    startGameMultiplayer();
}

function disconnectMultiplayer() {
    if (conn && conn.open) {
        sendData({ type: 'DISCONNECT_FORCE' });
        conn.close();
    }

    if (peer && !peer.destroyed) {
        peer.destroy();
    }

    conn = null;
    peer = null;

    isMultiplayer = false;
    isHost = false;
    isRunning = false;

    hideAllMenus();
    showMainMenu();

    // Buat peer baru untuk session baru
    setTimeout(() => {
        initPeerConnection();
    }, 500);
}


function initPeerConnection() {
    peer = new Peer({
        debug: 2
    });

    peer.on('error', (err) => {
        console.error("Peer error:", err);
    });
}

function forceReturnToMainMenu() {
    if (conn && conn.open) conn.close();
    if (peer && !peer.destroyed) peer.destroy();

    conn = null;
    peer = null;

    isMultiplayer = false;
    isRunning = false;

    hideAllMenus();
    showMainMenu();

    // REGISTRASI ulang peer baru setelah disconnect benar
    setTimeout(() => {
        initPeerConnection();
    }, 500);
}


function checkIfFinalResult() {
    const waitingMsg = document.getElementById("waitingMessage"); // tag <p> warna hijau
    if (!opponentGameOver) {
        waitingMsg.style.display = "block"; // ===> Gambar 2
        return;
    }
    waitingMsg.style.display = "none"; // ===> Gambar 3
    showMultiplayerResults();
}

function showMultiplayerResults() {
    hideAllMenus();
    document.getElementById('multiplayerResultsMenu').style.display = 'flex';

    // Pastikan urutan sesuai host/joiner
    const p1 = isHost ? score : opponentScore;
    const p2 = isHost ? opponentScore : score;

    p1FinalScore.innerText = p1;
    p2FinalScore.innerText = p2;

    let winText = "SERI!";
    if (p1 > p2) winText = "Pemenang: PLAYER 1 (HOST)";
    else if (p2 > p1) winText = "Pemenang: PLAYER 2 (JOINER)";
    winnerMessage.innerText = winText;
}

function updateMultiplayerResultUI() {
    // Pastikan elemen ada
    const waitingMsg = document.getElementById('waitingMessage'); // teks "Menunggu lawan..."
    // Ambil elemen skor final
    const p1El = document.getElementById('p1FinalScore');
    const p2El = document.getElementById('p2FinalScore');
    const winnerEl = document.getElementById('winnerMessage');

    // Tentukan nilai p1/p2 berdasarkan peran host/joiner
    // p1 selalu HOST, p2 selalu JOINER
    const myScore = Number(score) || 0;
    let p1Score, p2Score;
    if(isHost){
        p1Score = myScore;
        p2Score = Number(opponentScore) || 0;
    } else {
        p1Score = Number(opponentScore) || 0;
        p2Score = myScore;
    }

    if(p1El) p1El.innerText = p1Score.toLocaleString();
    if(p2El) p2El.innerText = p2Score.toLocaleString();

    // jika lawan belum selesai, tampilkan pesan menunggu
    if(!opponentGameOver){
        if(waitingMsg) {
            waitingMsg.style.display = 'block';
            waitingMsg.innerText = "Menunggu lawan menyelesaikan permainan...";
        }
        if(winnerEl) winnerEl.innerText = "";
    } else {
        // lawan sudah selesai -> sembunyikan waiting msg, tampilkan pemenang apabila sudah kedua2 selesai
        if(waitingMsg) waitingMsg.style.display = 'none';

        // Jika saya sudah selesai atau lawan juga sudah selesai, bisa tampilkan pemenang
        // Tampilkan pemenang hanya jika kedua pemain sudah selesai (safety)
        if(!isRunning && opponentGameOver){
            // tampilkan winner
            if(p1Score > p2Score) {
                if(winnerEl) winnerEl.innerText = "Pemenang: PLAYER 1 (HOST)";
            } else if(p2Score > p1Score){
                if(winnerEl) winnerEl.innerText = "Pemenang: PLAYER 2 (JOINER)";
            } else {
                if(winnerEl) winnerEl.innerText = "SERI!";
            }
        } else {
            // jika saya masih bermain tetapi lawan sudah finish -> tunggu saya selesai; jangan deklarasi pemenang
            if(winnerEl) winnerEl.innerText = "";
        }
    }
}


</script>
<script>
    initPeerConnection();

// GAMEPLAY: spawn/place/clear/update/draw etc.

// Board reset & spawn
function resetBoard(){ board = []; for(let r=0;r<ROWS;r++) board.push(new Array(COLS).fill(null)); }
function resetGame(){
    bag = randBag();
    nextPiece = createPiece(nextFromBag());
    current = null;
    holdPiece = null;
    score = 0; totalLines = 0; level = 1; dropInterval = 1000;
    resetBoard();
    updateScoreUI();
    spawn();
    isPaused=false; isRunning=true; lastTime=0; gameStartTime=Date.now();
    ensureAudio();
    requestAnimationFrame(update);
}

function startSingleplayer(){ isMultiplayer=false; hideAllMenus(); resetGame(); multiplayerStatusEl.innerText='Mode: Singleplayer'; rivalScoreContainer.style.display='none'; }
function startGameMultiplayer(){ isMultiplayer=true; hideAllMenus(); resetGame(); multiplayerStatusEl.innerText='Mode: Multiplayer'; rivalScoreContainer.style.display='block'; }

// Main spawn/placement
function spawn(){
    if(!nextPiece) nextPiece = createPiece(nextFromBag());
    current = nextPiece;
    nextPiece = createPiece(nextFromBag());
    if(collide(board, current.shape, current.x, current.y)){ handleGameOver(); }
}
function placePiece(){
    let linesCleared = 0;
    current.shape.forEach((row,r)=> row.forEach((v,c)=>{ if(v){ const bx=current.x+c, by=current.y+r; if(by>=0) board[by][bx] = current.color; } }));
    for(let r=ROWS-1;r>=0;r--){
        if(board[r].every(cell=>cell)){
            board.splice(r,1);
            board.unshift(new Array(COLS).fill(null));
            linesCleared++;
            r++;
        }
    }
    if(linesCleared>0){
        totalLines += linesCleared;
        score += scoreFor(linesCleared);
        playSimple('clear');
        if(isMultiplayer && conn && conn.open){
            sendData({ type:'UPDATE_SCORE', score: score });
            let garbage = 0;
            if(linesCleared===2) garbage = 1;
            else if(linesCleared===3) garbage = 2;
            else if(linesCleared===4) garbage = 4;
            if(garbage>0) sendData({ type:'ATTACK', count: garbage });
        }
    }
    level = Math.floor(totalLines/10) + 1;
    dropInterval = Math.max(100, 1000 - (level-1)*80);
    updateScoreUI()
    if(isMultiplayer && conn && conn.open){
    sendData({ type: 'UPDATE_SCORE', score: score });
    };
}

function scoreFor(lines){ const map = {1:100,2:300,3:500,4:800}; return map[lines] || 0; }
function hardDrop(){ while(!collide(board,current.shape,current.x,current.y+1)) current.y++; placePiece(); playSimple('drop'); spawn(); }
function softDrop(){ if(!collide(board,current.shape,current.x,current.y+1)){ current.y++; score++; } else { placePiece(); spawn(); } }
function move(dx){ if(!collide(board,current.shape,current.x+dx,current.y)) { current.x += dx; playSimple('click'); } }
function rotateCurrent(){ const r = rotateShape(current.shape); if(!collide(board,r,current.x,current.y)){ current.shape = r; playSimple('click'); return; } if(!collide(board,r,current.x-1,current.y)){ current.x--; current.shape = r; playSimple('click'); return; } if(!collide(board,r,current.x+1,current.y)){ current.x++; current.shape = r; playSimple('click'); return; } }
function swapHold(){ if(!current) return; if(!holdPiece){ holdPiece = createPiece(current.key); spawn(); } else { const temp = createPiece(current.key); current = createPiece(holdPiece.key); holdPiece = temp; current.x = Math.floor(COLS/2 - Math.ceil(current.shape[0].length/2)); current.y = 0; } playSimple('click'); }

// Garbage (received from opponent)
function addGarbageLines(count){
    if(!isRunning || isPaused) return;
    playSimple('drop');
    for(let i=0;i<count;i++){
        board.shift();
        const row = new Array(COLS).fill('#555');
        row[Math.floor(Math.random()*COLS)] = null;
        board.push(row);
    }
}

// Game over handling
function handleGameOver() {
    isRunning = false;
    isPaused = true;
    stopBGM();

    if (!isMultiplayer) {
        showMenu('gameOverMenu');
        return;
    }

    sendData({ type: 'GAME_OVER', score });

    hideAllMenus();
    myGameOverOverlay.style.display = 'flex';
    btnCheckResult.style.display = 'block';  // SELALU tampil
}



function gameWin(){
    isRunning = false; isPaused = true; stopBGM();
    // show results
    showMultiplayerResults();
}

function showMultiplayerResults(){
    // Tampilkan result final (dipanggil saat kedua telah selesai)
    hideAllMenus();
    document.getElementById('multiplayerResultsMenu').style.display = 'flex';
    // pastikan update UI dengan nilai terbaru
    updateMultiplayerResultUI();
    // kalau kedua sudah selesai, deklarasikan pemenang
    const p1 = Number(document.getElementById('p1FinalScore').innerText.replace(/,/g,'')) || 0;
    const p2 = Number(document.getElementById('p2FinalScore').innerText.replace(/,/g,'')) || 0;
    const winnerEl = document.getElementById('winnerMessage');
    if(p1 > p2) winnerEl.innerText = "Pemenang: PLAYER 1 (HOST)";
    else if(p2 > p1) winnerEl.innerText = "Pemenang: PLAYER 2 (JOINER)";
    else winnerEl.innerText = "SERI!";
}

// UI & draw
function updateScoreUI(){ scoreEl.innerText = score.toLocaleString(); levelEl.innerText = level; linesEl.innerText = totalLines; document.getElementById('highscore').innerText = highScore.toLocaleString(); }
function updateTime(){ const el = Date.now()-gameStartTime; const m=Math.floor(el/60000).toString().padStart(2,'0'); const s=Math.floor((el%60000)/1000).toString().padStart(2,'0'); timeEl.innerText = `${m}:${s}`; }

function computeGhostY(){
    if(!current) return 0;
    let gy = current.y;
    while(!collide(board,current.shape,current.x,gy+1)) gy++;
    return gy;
}

function drawShapeAt(shape,x,y,color,isCurrent=false){
    for(let r=0;r<shape.length;r++) for(let c=0;c<shape[r].length;c++) if(shape[r][c]){
        ctx.fillStyle = color;
        ctx.fillRect((x+c)*BLOCK, (y+r)*BLOCK, BLOCK, BLOCK);
        if(isCurrent){ ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect((x+c)*BLOCK+5, (y+r)*BLOCK+5, BLOCK-10, BLOCK-10); }
    }
}

function draw(){
    ctx.clearRect(0,0,boardCanvas.width,boardCanvas.height);
    // grid lines
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-line');
    ctx.lineWidth = 1;
    for(let c=1;c<COLS;c++){ ctx.beginPath(); ctx.moveTo(c*BLOCK,0); ctx.lineTo(c*BLOCK,boardCanvas.height); ctx.stroke(); }
    for(let r=1;r<ROWS;r++){ ctx.beginPath(); ctx.moveTo(0,r*BLOCK); ctx.lineTo(boardCanvas.width,r*BLOCK); ctx.stroke(); }
    // board
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(board[r][c]){ ctx.fillStyle = board[r][c]; ctx.fillRect(c*BLOCK, r*BLOCK, BLOCK, BLOCK); ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(c*BLOCK+5, r*BLOCK+5, BLOCK-10, BLOCK-10); }
    if(current){
        const ghostY = computeGhostY();
        drawShapeAt(current.shape, current.x, ghostY, 'rgba(255,255,255,0.08)');
        drawShapeAt(current.shape, current.x, current.y, current.color, true);
    }
}

// draw next & hold
function drawNext(){
    nextCanvasCtx.clearRect(0,0,120,180);
    if(!nextPiece) return;
    const grid = nextPiece.shape;
    const w = grid[0].length, h = grid.length;
    const sx = Math.floor((120 - w*20)/2);
    const sy = Math.floor((180 - h*20)/2);
    for(let r=0;r<h;r++) for(let c=0;c<w;c++) if(grid[r][c]){
        nextCanvasCtx.fillStyle = nextPiece.color;
        nextCanvasCtx.fillRect(sx + c*20, sy + r*20, 18, 18);
    }
}
function drawHold(){
    holdCanvasCtx.clearRect(0,0,120,80);
    if(!holdPiece) return;
    const grid = holdPiece.shape;
    const w = grid[0].length, h = grid.length;
    const sx = Math.floor((120 - w*18)/2);
    const sy = Math.floor((80 - h*18)/2);
    for(let r=0;r<h;r++) for(let c=0;c<w;c++) if(grid[r][c]){
        holdCanvasCtx.fillStyle = holdPiece.color;
        holdCanvasCtx.fillRect(sx + c*18, sy + r*18, 16, 16);
    }
}

function update(time=0){
    if(!isRunning) return;
    if(!lastTime) lastTime = time;
    const delta = time - lastTime; lastTime = time;
    if(!isPaused){
        dropCounter += delta;
        if(dropCounter > dropInterval){
            dropCounter = 0;
            if(!collide(board,current.shape,current.x,current.y+1)){
                current.y++;
            } else {
                placePiece(); spawn();
            }
        }
        updateTime();
        draw(); drawNext(); drawHold();
    }
    requestAnimationFrame(update);
}

// small helpers bound earlier:
function resumeGame(){ if(isRunning){ hideAllMenus(); isPaused=false; if(soundOn) startBGM(); } }
document.getElementById('btnToggleSound2').onclick = function(){ soundOn=!soundOn; if(soundOn) { ensureAudio(); startBGM(); } else stopBGM(); };
document.getElementById('goToResultBtn')?.addEventListener('click', function(){ /* optional */ });

</script>
</body>
</html>
